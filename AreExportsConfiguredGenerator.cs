/*
    duge.SourceGenerator.AreExportsConfigured

    Copyright (C) 2024 Juan Pablo Arce

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, see <https://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace duge.SourceGenerator.AreExportsConfigured
{
    [Generator]
    public class AreExportsConfiguredGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
        }

        public void Execute(GeneratorExecutionContext context)
        {
            IEnumerable<ClassDeclarationSyntax> classDeclarations = context.Compilation.SyntaxTrees
                .SelectMany(tree =>
                    tree
                        .GetRoot()
                        .DescendantNodes()
                        .OfType<ClassDeclarationSyntax>());
            IEnumerable<ITypeSymbol> nodeDeclarationSymbols = classDeclarations
                .Select(declaration =>
                    context
                        .Compilation
                        .GetSemanticModel(declaration.SyntaxTree)
                        .GetDeclaredSymbol(declaration))
                .OfType<ITypeSymbol>()
                .Where(symbol => symbol.InheritsFrom("GodotSharp", "Godot.Node"))
                .ToImmutableArray();

            foreach (ITypeSymbol node in nodeDeclarationSymbols)
            {
                ITypeSymbol? baseType = node.BaseType;

                string nodeNs = node.ContainingNamespace is { IsGlobalNamespace: false }
                    ?  node.ContainingNamespace.FullQualifiedNameOmitGlobal()
                    : string.Empty;

                StringBuilder outputSource = new StringBuilder();
                outputSource.AppendLine("// <auto-generated/>");

                outputSource.AppendLine("using System.Diagnostics.CodeAnalysis;");
                outputSource.AppendLine("using Godot;");

                if (!string.IsNullOrWhiteSpace(nodeNs))
                {
                    outputSource.AppendLine($"namespace {nodeNs} {{");
                }

                string typeParameters =
                    node is INamedTypeSymbol { IsGenericType: true } genericType
                        ? $"<{string.Join(",", genericType.TypeParameters.Select(p => p.Name))}>"
                        : "";
                
                outputSource.AppendLine($"partial class {node.Name}{typeParameters} {{");

                if (GetNullableExports(node, includeParentExports: true) is { Length: > 0 } allNullableExports)
                {
                    outputSource.AppendLine(
                        $"[MemberNotNullWhen(true, {string.Join(", ", allNullableExports.Select(m => $"\"{m.Name}\""))})]");
                }

                string startingReturnValue = "true";
                string virtualKeyword = "virtual";
                if (node.IsSealed)
                {
                    virtualKeyword = "";
                }
                if (baseType != null
                    && nodeDeclarationSymbols.Any(otherNode => TrimGenericParameters(otherNode.FullQualifiedNameOmitGlobal()) == TrimGenericParameters(baseType.FullQualifiedNameOmitGlobal())))
                {
                    startingReturnValue = "base.AreExportsConfigured()";
                    virtualKeyword = "override";
                }
                
                outputSource.AppendLine($"public {virtualKeyword} bool AreExportsConfigured() {{");
                
                outputSource.AppendLine($"bool returnValue = {startingReturnValue};");

                foreach (ISymbol member in GetNullableExports(node, includeParentExports: false))
                {
                    outputSource.AppendLine($"if ({member.Name} is null) {{");
                    outputSource.AppendLine($"GD.PushError($\"Configuration error in {{GetPath()}}: {node.Name}.{member.Name} is null!\");");
                    outputSource.AppendLine("returnValue = false;");
                    outputSource.AppendLine("}");
                }
                
                outputSource.AppendLine("return returnValue;");

                // Close method
                outputSource.AppendLine("}");
                // Close class
                outputSource.AppendLine("}");
                if (!string.IsNullOrWhiteSpace(nodeNs))
                {
                    // Close namespace
                    outputSource.AppendLine("}");
                }

                string outputPath = $"{node.FullQualifiedNameOmitGlobal()}.g.cs";
                
                context.AddSource(string.Join("_", outputPath.Split(Path.GetInvalidFileNameChars())), outputSource.ToString());
            }
        }

        private static bool IsNullable(ISymbol member)
        {
            ITypeSymbol memberType;
            switch (member)
            {
                case IPropertySymbol propertySymbol:
                    memberType = propertySymbol.Type;
                    break;
                case IFieldSymbol fieldSymbol:
                    memberType = fieldSymbol.Type;
                    break;
                default:
                    return false;
            }

            // FIXME: if Godot ever adds support for exporting Nullable<T>, account for that here.
            // Nullable<T> is still a value type, it just gets special syntax to make it look like
            // a nullable reference type.
            return !memberType.IsValueType;
        }

        private static string TrimGenericParameters(string typeString)
        {
            return typeString.IndexOf("<", StringComparison.Ordinal) is >= 0 and var index
                ? typeString.Substring(0, index)
                : typeString;
        }

        private static ImmutableArray<ISymbol> GetNullableExports(ITypeSymbol? nodeSymbol, bool includeParentExports)
        {
            List<ISymbol> exports = new List<ISymbol>();

            while (nodeSymbol != null)
            {
                IEnumerable<ISymbol> newExports = nodeSymbol.GetMembers()
                    .Where(member => member.GetAttributes()
                        .Any(attr => attr.AttributeClass?.FullQualifiedNameOmitGlobal() == "Godot.ExportAttribute"))
                    .Where(IsNullable)
                    .Where(parentExport => !exports.Any(export => export.Name == parentExport.Name));

                exports.AddRange(newExports);

                nodeSymbol = includeParentExports ? nodeSymbol.BaseType : null;
            }

            return exports.ToImmutableArray();
        }
    }
}